<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.73.0" />

    
    
    

<title>Reactive log stream processing with RxJava - Part I â€¢ Serban Balamaci</title>













    
<meta property="og:locale" content="en">
<meta property="og:site_name" content="Serban Balamaci">
<meta property="og:title" content="Reactive log stream processing with RxJava - Part I">
<meta property="og:type" content="website">
<meta property="og:url" content="https://balamaci.ro/2016/08/10/reactive-log-processing/" />
<meta property="og:description" content="Java mostly, and general tech">
<meta property="og:image" content="https://balamaci.ro/social-sharing.png">
<meta property="og:image:type" content="image/png">
    
    
    
<meta property="og:image:width" content="192">
<meta property="og:image:height" content="192">
    

<meta property="og:updated_time" content="2016-08-10T14:09:03Z">



<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@sbalamaci">
<meta name="twitter:title" content="Reactive log stream processing with RxJava - Part I">

<meta name="twitter:image" content="https://balamaci.ro/social-sharing.png">

<meta name="twitter:description" content="Java mostly, and general tech">
<meta name="twitter:creator" content="@sbalamaci">
    
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/a11y-light.min.css" media="(prefers-color-scheme: light)"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/gruvbox-dark.min.css" media="(prefers-color-scheme: dark)">




<link rel="stylesheet" href="/scss/hyde-hyde.57d57be207f95258b69c5563e34ed2c632000ecb862ce9bd97e7e35f3957094c.css" integrity="sha256-V9V74gf5Uli2nFVj407SxjIADsuGLOm9l&#43;fjXzlXCUw=">


<link rel="stylesheet" href="/scss/hyde-hyde-dark.2eddfb769610f72f40f6bc949e62a3acf298eb8504c073739085a417978b18cd.css" integrity="sha256-Lt37dpYQ9y9A9ryUnmKjrPKY64UEwHNzkIWkF5eLGM0=" media="(prefers-color-scheme: dark)">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    
    <link rel="shortcut icon" sizes="192x192" href="/android-192-favicon.png">

    
    <link rel="shortcut icon" href="/android-192-favicon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/v4-shims.min.css" integrity="sha256-wN7QJaqAwQ03kgUhyN4EU2phRdDkLrQYbFe0EvpQ60U=" crossorigin="anonymous" />

    
    


    
</head>


    <body class="">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://balamaci.ro">Serban Balamaci</a>
      </span>
      
      
        <div class="author-image">
          <img src="https://www.gravatar.com/avatar/309afbf8c2f162060e4fa28d670d2ec8?s=240&d=mp" class="img--circle img--headshot element--center" alt="gravatar">
        </div>
      
      <p class="site__description">
         Java and JVM related 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Serban Balamaci</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/"><span class='fa-icon'><i class='fas fa-home'></i></span> Home
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/"><span class='fa-icon'><i class='fas fa-stream'></i></span> Posts
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/series/"><span class='fa-icon'><i class='fas fa-list-alt'></i></span> Series
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/"><span class='fa-icon'><i class='fas fa-tags'></i></span> Tags
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/whoami/"><span class='fa-icon'><i class='fas fa-id-card'></i></span> About
						<span></span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/@sbalamaci" rel="me"><i class="fa-w-16" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="bird" class="svg-inline--fa fa-bird fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></i></a>
	
	
	
	<a href="https://github.com/balamaci" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/serbanbalamaci" rel="me"><i class="fa-w-16" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="pro-network" class="svg-inline--fa fa-pro-network fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></i></a>
	
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>

  </div>
  <div class="container fixed-container">
    
<div class="copyright">
  &copy; 2010 - 2020 Serban Balamaci
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>



  </div>
</div>

        <div class="content container">
            
    

<article>
  <header>
    <h1>Reactive log stream processing with RxJava - Part I</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> 2016-08-10
    
    
    
    
    
    <br/>
    <i class="fas fa-clock"></i> 43 min read

    
    
    

</div>


  </header>
  
  
  
  <div class="post md">
    <h3 id="centralized-logs-as-a-data-source-for-realtime-data-analysis">Centralized logs as a data source for realtime data analysis</h3>
<p>In the previous blog entries we saw how we can leverage the power of the ELK stack for log collection and analysis of our Java apps.</p>
<p>With the move towards microservices or containerization of applications it becomes the defacto standard to have a stack for centralized log processing and storage.
Can we maybe go the next step and use that information proactively instead of just for just finding the cause of problems long after they appeared?</p>
<p>If <strong>we were to consider the log events as a stream of data for things happening in realtime</strong> in your system it would be very interesting to tap into and perform <strong>realtime data analysis</strong> with all sorts of uses like <strong>detecting fraudulent behavior</strong> for example by aggregating different streams of information while the &ldquo;attack&rdquo; is happening and block the attacker instead of the &ldquo;traditional&rdquo; way of just using log data for forensics to investigate after the issue appeared.</p>
<p>For ex. we could <strong>filter</strong> only events of a certain type, <strong>&lsquo;group by&rsquo;</strong> a common key like the userID and count them in a time-window to get the number of actions of that type the user is doing in a certain timeframe.</p>
<pre><code class="language-java">  failedLoginsStream()
                .window(5, TimeUnit.SECONDS)
                .flatMap(window -&gt;
                          window
                            .groupBy(propertyStringValue(&quot;remoteIP&quot;))
                            .flatMap(grouped -&gt; grouped
                                .count()
                                .map(failedLoginsCount -&gt; {
                                    final String remoteIp = grouped.getKey();
                                    return new Pair&lt;&gt;(remoteIp, failedLoginsCount);
                                }))
                )
                .filter(pair -&gt; pair.get &gt; 10)
                .forEach(system.out:println);
</code></pre>
<p>We could trigger queries in other systems and treat those responses as streams to which we can subscribe and apply <strong>a multitude of common stream operators</strong> that reactive streams frameworks provide.</p>
<p>And the good thing is that since you&rsquo;re working with already existing log outputs you can build this separate and extend it without touching or polluting the business logic of the application.</p>
<h3 id="learning-a-new-programming-paradigm">Learning a new programming paradigm</h3>
<p>This could be a good excuse to get into the world of <strong>Reactive stream programming</strong>.
Reactive programming is about <strong>non-blocking</strong>, <strong>event-driven</strong> applications that scale even on a small number of threads with back-pressure(feedback mechanism to ensure producers do not overwhelm consumers).</p>
<p>The biggest new thing <strong>Spring5 will bring will be <a href="https://spring.io/blog/2016/04/19/understanding-reactive-types">Reactive support</a></strong>. A new module <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-web-reactive">spring-web-reactive</a> a framework similar with spring-web-mvc that enables async response(non blocking) REST services and a reactive web-client and  that will probably work great for microservice architectures.
The reactive-streams concepts is not just Spring specific, but instead there is a common specification <a href="https://github.com/reactive-streams/reactive-streams-jvm">reactive-streams-jvm</a> agreed upon by the major reactive frameworks(so while there might not be exact name matches the concepts will make it easy to switch frameworks).
Historically Rx.NET introduced the reactive-streams model, and Netflix ported it to java with RxJava. Then the concept has been implemented into other languages as well, under the <a href="http://reactivex.io/">Reactive EXtensions</a> umbrella.<br>
Then since other companies were going kinda in the same direction the <a href="http://www.reactive-streams.org/">reactive-streams</a> specification took of. Now <strong>RxJava</strong> since it was kind of the pioneer needs to do a bigger refactor(in version <strong><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">2.x</a></strong> to better match the specification, while <strong>Spring reactor</strong> being newer could start fresh with directly implementing the spec.
You care read more about how they <a href="https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape">relate</a>.</p>
<p>Also reactive streams will come to Java 9 as Doug Lea wants to include the reactive-streams under container object <a href="http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/Flow.html">java.util.concurrent.Flow</a></p>
<h4 id="benefits-from-a-performance-perspective">Benefits from a performance perspective</h4>
<p>Also another buzzword right now is the <strong>microservices architecture</strong> where you need to be able to make requests to multiple other services. Ideally you&rsquo;d want to do it <strong>without blocking</strong> waiting for the whole response before making the request to the next service. Think that instead of waiting for a whole possibly huge List<!-- raw HTML omitted --> to be returned by a service, it might be the case to start a query in another system as soon as the first element is available.</p>
<p><img src="/assets/rxjava/dogs.jpg" alt="Never block"></p>
<p>Treating that remote call response as a Stream to which we subscribe for an action when the response arrives, instead of blocking the thread waiting for the response means we can use <strong>less threads overall</strong> which in turn means <strong>less resources wasted(cpu for context switching between threads and memory for each thread stack)</strong>.
So by using reactive programming we should be <strong>able to handle a larger amount of log events with commodity hardware</strong>.</p>
<p>An example: If we&rsquo;re a service like GMail and we need to display the user&rsquo;s emails. However emails in turn might have many people in CC. It would be nice to display a photo of those that the user has in his contacts - which means a REST call in the ContactsService</p>
<p>We&rsquo;d normally have something like</p>
<pre><code class="language-java">Future&lt;List&lt;Mail&gt;&gt; emailsFuture = mailstoreService.getUnreadEmails();
List&lt;Mail&gt; emails = emailsFuture.get(); //blocking the current thread
//waiting possibly for a long time to get the whole list
//we cannot start next processing as soon as the first email is found??

Future&lt;List&lt;Contacts&gt;&gt; contacts = getContactsForEmails(emails);
for(Mail mail : emails) {
  streamRenderEmails(mail, contacts); //push emails to the client
}
</code></pre>
<p>Partially the problem has been improved with the reactive support from Java8 with <strong>CompletableFuture</strong>(which with it&rsquo;s thenCompose, thenCombine, thenAccept and other 50 something methods it&rsquo;s not making it easy to remember what each method does, which in turn I think doesn&rsquo;t help readability).</p>
<pre><code>CompletableFuture&lt;List&lt;Mail&gt;&gt; emailsFuture = mailstoreService.getUnreadEmails();

CompletableFuture&lt;List&lt;Contact&gt;&gt; emailsFuture
  .thenCompose(emails -&gt; getContactsForEmails(emails)) //we still need to wait for the List&lt;Mail&gt; to 
  .thenAccept(emailsContactsPair -&gt; streamRenderEmails(emailsContactsPair.getKey(), emailsContactsPair.getValue()))
</code></pre>
<p>we could switch to an Iterator data type instead of List still there are no methods to tell it to do something when a new value arrives. SQL does this with returning the ResultSet(on which you can do rs.next()) instead of getting the whole data in memory.</p>
<pre><code>public interface Iterator&lt;E&gt; {
    /**
     * Returns {@code true} if the iteration has more elements.
     */
    boolean hasNext();

    /**
     * Returns the next element in the iteration.
     */
    E next();
}
</code></pre>
<p>But we need to constantly ask &ldquo;do you have a new value&rdquo;?</p>
<pre><code>Iterable&lt;Mail&gt; emails = mailstoreService.getUnreadEmails();
Iterator&lt;Mail&gt; emailsIt = emails.iterator();

while(emailsIt.hasNext()) {
  Mail mail = emailsIt.next(); //nonblockin but we still need to constantly waste cpu asking
  if(mail != null) {           //for new values
      ....
  }
}

</code></pre>
<p>What we&rsquo;d need instead would be like a <strong>reactive Iterator</strong>, a datatype to which you could subscribe for an action to be executed once there is a new value ready and this is where reactive stream programming begins.</p>
<h4 id="so-what-is-a-stream">So what is a Stream?</h4>
<p><img src="https://camo.githubusercontent.com/e581baffb3db3e4f749350326af32de8d5ba4363/687474703a2f2f692e696d6775722e636f6d2f4149696d5138432e6a7067" alt="Everything is a stream"></p>
<p>A Stream is simply <strong>a sequence of events ordered in time</strong> (eventX was emitted after eventY, <strong>there are no concurrent events</strong>).</p>
<p>A Stream is modeled so it can emit <strong>0..N events</strong> and <strong>either one of two terminal operations</strong>:</p>
<ul>
<li><strong>completed</strong> event through which it signals subscribers that it finished emitting data</li>
<li><strong>error</strong> event for signaling it finished exceptionally</li>
</ul>
<p>We can describe that visually with the use of &lsquo;marble diagrams&rsquo;.
<img src="/assets/rxjava/RxJava1.svg" alt="Marble diagram for Observable"></p>
<p>So everything can be thought as being a Stream, not just log events. Even a single value can be expressed as a Stream by emitting the value followed by an <strong>completed</strong> event.
An infinite stream is one that only emits events but not any of the terminal events(completed | error).</p>
<p>RxJava defines the <strong>Observable<!-- raw HTML omitted --></strong> <strong>data type</strong> to model the Stream of events of type &lt;T&gt;. Spring Reactor&rsquo;s equivalent is <a href="https://projectreactor.io/core/docs/api/reactor/core/publisher/Flux.html">Flux<!-- raw HTML omitted --></a></p>
<ul>
<li>
<p>Observable&lt;Double&gt; to represent a stream of temperatures taken at various intervals.</p>
</li>
<li>
<p>Observable&lt;CartItem&gt; to represent a stream of products bought in our web store.</p>
</li>
<li>
<p>Observable&lt;User&gt; to represent a single User returned by a DB query</p>
</li>
</ul>
<pre><code>    public Observable&lt;User&gt; findByUserId(String userId) {...}
    //or Single for being more explicit 
    public Single&lt;User&gt; findByUserId(String userId) {...}
</code></pre>
<p>But <strong>Observable&lt;T&gt;</strong> is just a datatype and same as the Publish/Subscriber pattern, we need a Subscriber to process the 3 types of events</p>
<pre><code class="language-java">        Observable&lt;CartItem&gt; cartItemsStream = ...;

        Subscriber&lt;CartItem&gt; subscriber = new Subscriber&lt;CartItem&gt;() {
            @Override
            public void onNext(CartItem cartItem) {
                System.out.println(&quot;Cart Item added &quot; + cartItem);
            }

            @Override
            public void onCompleted() {
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
            }
        };

        cartItemsStream.subscribe(subscriber);
</code></pre>
<h4 id="reactive-operators">Reactive operators</h4>
<p>But that is just the Stream part, and until now we&rsquo;ve not been doing something more special than the classic Observer pattern.<br>
The <strong>Reactive</strong> part means we can <strong>define some Function</strong>(the <strong>operators</strong>) that will be executed when the stream emits an event.
That means another stream will be created(streams are immutable) to which we can subscribe another operator and so on.</p>
<pre><code class="language-java">Observable&lt;CartItem&gt; filteredCartStream = cartStream.filter(new Func1&lt;CartItem, Boolean&gt;() {
            @Override
            public Boolean call(CartItem cartItem) {
                return cartItem.isLaptop();
            }
        });

Observable&lt;Long&gt; laptopCartItemsPriceStream = filteredCartStream.map(new Func1&lt;CartItem, Long&gt;() {
            @Override
            public Long call(CartItem cartItem) {
                try {
                    return priceService.getPrice(cartItem.getId());
                } catch(PriceServiceException e) {
                    thrown new RuntimeException(e);
                }
            }
        });
</code></pre>
<p>Since the operator methods of the Observable class(filter, map, groupBy,&hellip;) return Observable, it means <strong>we can chain the operators together</strong> and combined with lambda syntax we can write something pretty</p>
<pre><code>Observable&lt;BigDecimal&gt; priceStream = cartStream
                        .filter((cartItem) -&gt; cartItem.isLaptop()).
                        .map((laptop) -&gt; {
                             try {
                                  return priceService.getPrice(cartItem.getId());
                            } catch(PriceServiceException e) {
                                 thrown new RuntimeException(e);
                            }
                        });
</code></pre>
<p>The thing to notice above is that <strong>when creating <em>priceStream</em> nothing is happening</strong> in the sense that <strong>priceService.getPrice()</strong> is not getting invoked until there is an item flowing through the operators chain.
That means we created through the rx-operators sort of a blueprint of how the data will be manipulated once it starts flowing downstream(a subscriber registers).</p>
<p>When asked to explain <strong>reactive programming</strong> people jokingly give as an example an Excel sheet where you write the formulas for columns and as soon as you update a cell the formula is triggered which updates another cell which in turn triggers another formula and so on. Just like that the rx-operators don&rsquo;t do anything by themselves they are just formulas for data manipulation and each gets a chance to do it&rsquo;s thing before passing it down the chain.</p>
<p>To help understand better how events travel along the operators chain I found helpful the analogy of the house movers proposed by <a href="https://tomstechnicalblog.blogspot.ro/2015/10/understanding-observables.html">Thomas Nield</a> where each house mover is an operator passing along house objects.</p>
<p>He gives as example the following code:</p>
<pre><code class="language-java">Observable&lt;Item&gt; mover1 = Observable.create(s -&gt; {
   while (house.hasItems()) {
    s.onNext(house.getItem());
   }
   s.onCompleted();
});

Observable&lt;Item&gt; mover2 = mover1.map(item -&gt; putInBox(item));

Subscription mover3 = mover2.subscribe(box -&gt; putInTruck(box),
   () -&gt; closeTruck()); //this is what runs for onCompleted
</code></pre>
<p><img src="https://1.bp.blogspot.com/-1RuGVz4-U9Q/VjT0AsfiiUI/AAAAAAAAAKQ/xWQaOwNtS7o/s640/animation_2.gif" alt="Movers"></p>
<p>&ldquo;<strong>Mover 1</strong> on the far left is the <strong>source Observable</strong>. He creates the emissions by picking items out of the house.
He then calls onNext() on <strong>Mover 2, who does a map() operation</strong>. When his onNext() is called he takes that Item and puts it in a Box. Then he calls onNext() on <strong>Mover 3, the final Subscriber</strong> who loads the box on the truck.&rdquo;</p>
<p>The magic or RxJava is the large set of operators available and your job on how to combining them together to manipulate the flow of data.
<img src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/Composition.1.png" alt=""></p>
<p>The <strong>many Stream operators</strong> help establish <strong>a common vocabulary of manipulations when dealing with streams</strong> that can have implementations in popular languages(RxJava, RxJS, Rx.NET, etc) of the ReactiveX framework.
These concepts should be familiar even when using different reactive streams frameworks like <a href="">Spring Reactor</a>(with the hope of an agreement for a common base of <a href="https://github.com/reactor/reactive-streams-commons">operators</a>).</p>
<p>Until now we only saw simple operators like <strong>filter</strong>:</p>
<p><img src="http://reactivex.io/documentation/operators/images/filter.png" alt="Filter"></p>
<p>Which means but it only pushes downstream elements which pass the filtering condition(one mover drops everything with a value &lt; 100$ instead of passing it to the next mover)</p>
<p>There are however operators which can split a stream into many streams - Observable&lt;Observable&lt;T&gt;&gt;(Stream of Streams) - operators like  <strong>groupBy</strong></p>
<p><img src="https://blogs.endjin.com/wp-content/uploads/2014/04/event-stream-with-groupby1.png" alt="GroupBy"></p>
<pre><code class="language-java">        Observable&lt;Integer&gt; values = Observable.just(1,4,5,7,8,9,10);
        Observable&lt;GroupedObservable&lt;String, Integer&gt;&gt; oddEvenStream = values.groupBy((number) -&gt; number % 2 == 0 ? &quot;odd&quot;:&quot;even&quot;);
        Observable&lt;Integer&gt; remergedStream = Observable.concat(oddEvenStream);
        remergedStream.subscribe(number -&gt; System.out.print(number +&quot; &quot;));

//Outputs
//1 5 7 9 4 8 10 
</code></pre>
<p>and the rather simple operator <strong>concat</strong> which merges back the &ldquo;odd&rdquo; and &ldquo;even&rdquo; stream into a single one to which we subscribe.</p>
<p><img src="http://reactivex.io/documentation/operators/images/concat.png" alt="Concat"></p>
<p>as we can see the <strong>concat</strong> operator waits for a stream to complete before appending another one and so on, creating back a single stream. Thus the odd numbers were displayed first.</p>
<p>Also we have the way to merge back together multiple streams like <strong>zip</strong> operator
<img src="/content/images/2016/08/zip.png" alt="Zip Operator"></p>
<p>Zip is not named that way because it&rsquo;s acting like an archiving program but rather from the way a <strong>zipper</strong> works to combine events from two streams.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f0/Zipper_animated.gif" alt="Zipper"></p>
<p>It&rsquo;s taking one event from a stream and pairs it with another from the other stream as soon as one is ready, and applies a merging operator before sending it downstream.
PS: It also works with more than just two streams.</p>
<p>So even if one stream is emitting faster, the downstream listener will only see the combined event as soon as there is a matching event being emitted on the slower stream.
It&rsquo;s actually very useful as a way to &ldquo;wait&rdquo; for the response of multiple remote calls which return streams.</p>
<p>The <strong>combineLatest</strong> on the other hand it&rsquo;s not waiting for a pair emission to appear but instead uses the last emission from the slower stream before applying the merge function and sending it downstream.
<img src="https://camo.githubusercontent.com/2a1a467dc61743d40f92fd6df1038f4e2a3ded7c/687474703a2f2f692e696d6775722e636f6d2f3670316931447a2e706e67" alt="Combine latest"></p>
<h4 id="moving-to-a-push-based-mindset">Moving to a Push based mindset</h4>
<p>Let&rsquo;s see some examples of how you can actually create Observables. The most verbose variant but which let us understands more:</p>
<pre><code>log.info(&quot;Before create Observable&quot;);
Observable&lt;Integer&gt; someIntStream = Observable
    .create(new Observable.OnSubscribe&lt;Integer&gt;() {
                @Override
                public void call(Subscriber&lt;? super Integer&gt; subscriber) {
                    log(&quot;Create&quot;);

                    subscriber.onNext(3);
                    subscriber.onNext(4);
                    subscriber.onNext(5);
                    subscriber.onCompleted();

                    log(&quot;Completed&quot;);
                }
    });   
log.info(&quot;After create Observable&quot;);

log.info(&quot;Subscribing 1st&quot;);
someIntStream.subscribe((val) -&gt; log.info(&quot;received &quot; + val)); //we don't have to implement
//the other methods(for onError and onComplete) if we don't want to do something specific

log.info(&quot;Subscribing 2nd&quot;);
someIntStream.subscribe((val) -&gt; log.info(&quot;received &quot; + val));    
</code></pre>
<p><strong>Events are pushed onto the subscriber as soon as it subscribes</strong>. It&rsquo;s not doing this on construction, here we just passed it a <strong>new OnSubscribe</strong> object which represent what to do when someone subscribes.<br>
Until we subscribe to the Observable there is no output, there is nothing happening - the data is not flowing-.
When someone subscribes, the call() method is invoked and 3 events are pushed downstream followed by the signal that the stream completed.</p>
<p>Above we subscribed twice, the code inside call(&hellip;) method will be invoke twice also. So it&rsquo;s effectively re-pushing the same values as soon as someone else subscribes and the following output will be produced:</p>
<pre><code>mainThread: Before create Observable
mainThread: After create Observable
mainThread: Subscribing 1st
mainThread: Create
mainThread: received 3
mainThread: received 4
mainThread: received 5
mainThread: Completed
mainThread: Subscribing 2nd
mainThread: Create
mainThread: received 3
mainThread: received 4
mainThread: received 5
mainThread: Completed
</code></pre>
<p>Important thing to notice is that rx operators don&rsquo;t necessarily mean multithreading. RxJava doesn&rsquo;t inject any concurrency by default between the Observable and the Subscriber. This is why all the calls are happening on the &lsquo;main&rsquo; thread.</p>
<p>This kind of Observable that is starting even emission when someone subscribes is what we call <strong>cold observables</strong>. The other type is <strong>hot observables</strong>, they emit events even when nobody is subscribed.</p>
<ul>
<li>
<p><strong>Cold Observables</strong>
Only begins emitting the events when someone subscribes - they start the work(ex: makes a DB query) when subscribed to-. Each subscriber gets the same events.
Sort of <strong>like a CD where the same songs are played</strong> to whomever puts the cd into the player to listen.</p>
</li>
<li>
<p><strong>Hot Observables</strong>
Events are emitted even when there are no subscribers.
<strong>Like a radio stations where it plays the song in the air even when nobody is tuned in</strong>. Just like when you tune in later on a station, you miss previous events. Hot observables model events to which you don&rsquo;t have control over when they emit. Like when the log events are produced.</p>
</li>
</ul>
<p><strong>Subject</strong> s are special kind of Observable that is also an Observer(like Subscriber - which means we can push events(call onNext()) to them-) and make implementing hot Observables easier. There exists more implementations like <strong>ReplaySubject</strong> that keeps the emitted events in a buffer and replay them on subscription(you can ofcourse specify the size of the buffer to prevent OutOfMemory), while <strong>PublishSubject</strong> only pass on events that happened after subscription.</p>
<p>And of course there are more static helper methods for creating Observables from other sources</p>
<pre><code>Observable.just(&quot;This&quot;, &quot;is&quot;, &quot;something&quot;)
Observable.from(Iterable&lt;T&gt; collection)
Observable.from(Future&lt;T&gt; future) - emits the value when the future completes
</code></pre>
<!-- raw HTML omitted -->
<h3 id="adding-a-push-based-data-emitter-to-our-elk-stack---rabbitmq">Adding a push based data emitter to our ELK stack - RabbitMQ</h3>
<p>In a traditional <a href="https://balamaci.ro/java-app-monitoring-with-elk-logstash/">ELK</a> stack we use ElasticSearch to query the log events data so a more <strong>&lsquo;pull based&rsquo;</strong> system.
Could we have instead a <strong>push based</strong> where we&rsquo;re notified <strong>&ldquo;immediately&rdquo;</strong> when another log event appears to further reduce the reaction time from when the event is produced to when we begin processing it.
One of the many possible solutions would be <strong>RabbitMQ</strong> as being a battle tested solution with a very good reputation for performance for handling a huge amount of messages. Besides that Logstash already supplies a plugin for RabbitMQ(there is also one for FluentD) so we can easily integrate it in our existing ELK stack and write the log data both to ElasticSearch and RabbitMQ.
You may remember from that Logstash can act as a controller and choose how to process and where to send/store the log events. That means we can decide to filter log events we want to process or to send them to different RabbitMQ queues.</p>
<p>There is even the option to send data directly to RabbitMQ through a Logback <a href="http://docs.spring.io/spring-amqp/api/org/springframework/amqp/rabbit/logback/AmqpAppender.html">Appender</a> should you want to bypass Logstash.
Sidenote: While named AmqpAppender, it&rsquo;s rather specific to RabbitMQ AMQP implementation(AMQP protocol version 0-9-1, 0-9). ActiveMQ for ex.(while also supplying an AMQP connector) seems to implement AMQP protocol 1.0, while the spring-amqp library works with the protocol versions 0-9-1, 0-9 which are totally different at the wire level than 1.0) so you&rsquo;ll encounter a nice exception like
&lsquo;org.apache.activemq.transport.amqp.AmqpProtocolException: Connection from client using unsupported AMQP attempted&rsquo;</p>
<p>However our solution was to use <a href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> to send JSON formatted log events to Logstash. We&rsquo;ll now redirect the logstash output to a RabbitMQ exchange.</p>
<p>We&rsquo;ll use <strong>docker-compose</strong> to start up a logstash-rabbitmq cluster. You can clone the <a href="https://github.com/balamaci/blog-elk-docker">repo</a>.</p>
<pre><code>docker-compose -f docker-compose-rabbitmq.yml up
</code></pre>
<p>and you can use <strong>./event-generate.sh</strong> to generate some random events that get pushed to logstash.</p>
<p>It&rsquo;s using the logstash configuration <a href="https://github.com/balamaci/blog-elk-docker/blob/rabbitmq/logstash/config-rabbitmq/logstash.conf">file</a> to specify where we want to send the data. We use the <a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-rabbitmq.html">rabbitmq-output-plugin</a> as reference:</p>
<pre><code>output {
    rabbitmq {
        exchange =&gt; logstash
        exchange_type =&gt; direct
        host =&gt; rabbitmq
        key =&gt; my_app
    }
}
</code></pre>
<p>RabbitMQ is not a traditional JMS server, instead it uses the <strong>AMQP protocol</strong> which has quite a different concept for queues.</p>
<p><img src="http://blog.springsource.com/wp-content/uploads/2010/06/rabbit-basics.png" alt="AMQP"></p>
<p>A publisher sends messages to a named <strong>exchange</strong> and a consumer pulls messages from a queue. The message has a standard header &lsquo;routing-key&rsquo; which is used in a process called <strong>binding</strong> to associate an exchange message to a queue. The queues can filter which messages they receive via the binding key and you can use wildcards in the binding like &lsquo;logstash.*&rsquo;</p>
<p>For an indepth explanation for AMQP you can read <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">here</a> and <a href="https://www.cloudamqp.com/blog/2015-09-03-part4-rabbitmq-for-beginners-exchanges-routing-keys-bindings.html">here</a>.</p>
<p>So we <a href="https://github.com/balamaci/rxjava-rabbitmq/blob/master/src/main/java/com/balamaci/rx/configuration/AmqpSourceConfiguration.java">configured</a> a Spring connection to RabbitMq</p>
<pre><code>    @Bean
    ConnectionFactory connectionFactory() {
        return new CachingConnectionFactory(host, port);
    }

    @Bean
    RabbitAdmin rabbitAdmin() {
        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory());
        rabbitAdmin.declareQueue(queue());
        rabbitAdmin.declareBinding(bindQueueFromExchange(queue(), exchange()));
        return rabbitAdmin;
    }

    @Bean
    SimpleMessageListenerContainer container(ConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter) {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.setQueueNames(queueName);
        container.setMessageListener(listenerAdapter);

        return container;
    }

    @Bean
    Queue queue() {
        return new Queue(queueName, false);
    }

    DirectExchange exchange() {
        return new DirectExchange(&quot;logstash&quot;);
    }

    private Binding bindQueueFromExchange(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(&quot;my_app&quot;);
    }

    @Bean
    MessageListenerAdapter listenerAdapter(Receiver receiver) {
        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(receiver,
                new MessageConverter() {
            public Message toMessage(Object o, MessageProperties messageProperties)
                    throws MessageConversionException {
                throw new RuntimeException(&quot;Unsupported&quot;);
            }

            public String fromMessage(Message message) throws MessageConversionException {
                try {
                    return new String(message.getBody(), &quot;UTF-8&quot;);
                } catch (UnsupportedEncodingException e) {
                    throw new RuntimeException(&quot;UnsupportedEncodingException&quot;);
                }
            }
        });
        messageListenerAdapter.setDefaultListenerMethod(&quot;receive&quot;); //the method in our Receiver class
        return messageListenerAdapter;
    }


    @Bean
    Receiver receiver() {
        return new Receiver();
    }
</code></pre>
<p>We defined a queue and bind it to the &lsquo;logstash&rsquo; exchange to receive messages with the &lsquo;my_app&rsquo; routing key.
The <strong>MessageListenerAdapter</strong> above defines that the &lsquo;receive&rsquo; method should be called on Receiver bean every time a new message is received from the queue.</p>
<p>Since we&rsquo;re expecting a continuous stream of log events we don&rsquo;t have control over, we can think of using a hot observable that pushes events to all subscribers after they subscribed so we can use <strong>PublishSubject</strong> for the job.</p>
<pre><code>public class Receiver {
    private PublishSubject&lt;JsonObject&gt; publishSubject = PublishSubject.create();

    public Receiver() {
    }

    /**
     * Method invoked by Spring whenever a new message arrives
     * @param message amqp message
     */
    public void receive(Object message) {
        log.info(&quot;Received remote message {}&quot;, message);
        JsonElement remoteJsonElement = gson.fromJson ((String) message, JsonElement.class);
        JsonObject jsonObj = remoteJsonElement.getAsJsonObject();

        publishSubject.onNext(jsonObj);
    }

    public PublishSubject&lt;JsonObject&gt; getPublishSubject() {
        return publishSubject;
    }
}

</code></pre>
<p>We need to be aware that event the <strong>SimpleMessageListenerContainer</strong> supports having more than one thread that consumes from the queue(and emits the events downstream). However the Observable contract says we cannot emit events concurrently(calls to onNext,onComplete,onError must be serialized):</p>
<pre><code>// DO NOT DO THIS
Observable.create(s -&gt; {
                    // Thread A
                    new Thread(() -&gt; {
                        s.onNext(&quot;one&quot;);
                        s.onNext(&quot;two&quot;);
                    }).start();
                    
                    // Thread B
                    new Thread(() -&gt; {
                        s.onNext(&quot;three&quot;);
                        s.onNext(&quot;four&quot;);
                    }).start();
                });
// DO NOT DO THIS

//DO THIS
Observable&lt;String&gt; obs1 = Observable.create(s -&gt; {
                    // Thread A
                    new Thread(() -&gt; {
                        s.onNext(&quot;one&quot;);
                        s.onNext(&quot;two&quot;);
                    }).start();
                  });

Observable&lt;String&gt; obs2 = Observable.create(s -&gt; {
                    // Thread B
                    new Thread(() -&gt; {
                        s.onNext(&quot;three&quot;);
                        s.onNext(&quot;four&quot;);
                    }).start();
                });

Observable&lt;String&gt; c = Observable.merge(obs1, obs2);
</code></pre>
<p>We could go around this problem by calling Observable.serialize() or Subject.toSerialized() but since we just go with the default of 1 Thread in the ListenerContainer, there is no need to do so. Still you need to be aware of this if you plan to use Subjects as an event bus pushing events onto from multiple threads. Read a more <a href="https://artemzin.com/blog/rxjava-thread-safety-of-operators-and-subjects/">indepth explanation</a>.</p>
<p>For now, you can checkout out the code from the <a href="https://github.com/balamaci/rxjava-rabbitmq">repo</a> as we continue this long post in <a href="https://balamaci.ro/reactive-log-stream-processing-with-rxjava-part-2/">Part II</a> or go to the <a href="https://github.com/balamaci/rxjava-playground">Rx Playground</a> for some <strong>more examples</strong>.</p>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/2016/03/21/java-app-monitoring-with-elk-elastic-search/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Java app monitoring with ELK - Part II- ElasticSearch</span>
    </a>
    
    
    <a href="/2016/08/17/reactive-log-stream-processing-with-rxjava-part-2/" class="navigation-next">
      <span class="navigation-tittle">Reactive log stream processing with RxJava - Part II</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  

</article>


        </div>
        
    










<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin="anonymous"></script>
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    

<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js" integrity="sha256-vrn14y7WH7zgEElyQqm2uCGSQrX/xjYDjniRUQx3NyU=" crossorigin="anonymous"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);
</script>


    



    </body>
</html>

